<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TiDAR: Think in Diffusion, Talk in Autoregression</title>
    
    <!-- 1. 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 3. 引入 Framer Motion (动画库) -->
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    
    <!-- 4. 引入 Babel (用于在浏览器中编译 JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f9fafb; }
        /* Hide scrollbar for chrome/safari/opera */
        .no-scrollbar::-webkit-scrollbar {
          display: none;
        }
        /* Hide scrollbar for IE, Edge and Firefox */
        .no-scrollbar {
          -ms-overflow-style: none;  /* IE and Edge */
          scrollbar-width: none;  /* Firefox */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // 获取 React hooks 和 Framer Motion 组件
        const { useState, useRef, useEffect, useMemo } = React;
        const { motion, AnimatePresence, useMotionValue, useSpring, useTransform } = window.Motion;

        // --- 简易图标组件 (替代 lucide-react) ---
        const IconWrapper = ({ children, size = 24, className = "" }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className}
            >
                {children}
            </svg>
        );

        const Icons = {
            Brain: (props) => <IconWrapper {...props}><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></IconWrapper>,
            Cpu: (props) => <IconWrapper {...props}><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1v3"/><path d="M15 1v3"/><path d="M9 20v3"/><path d="M15 20v3"/><path d="M20 9h3"/><path d="M20 14h3"/><path d="M1 9h3"/><path d="M1 14h3"/></IconWrapper>,
            BookOpen: (props) => <IconWrapper {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconWrapper>,
            BarChart3: (props) => <IconWrapper {...props}><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></IconWrapper>,
            CheckCircle: (props) => <IconWrapper {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconWrapper>,
            HelpCircle: (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></IconWrapper>,
            ChevronRight: (props) => <IconWrapper {...props}><polyline points="9 18 15 12 9 6"/></IconWrapper>,
            ArrowRight: (props) => <IconWrapper {...props}><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></IconWrapper>,
            Zap: (props) => <IconWrapper {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconWrapper>,
            Layers: (props) => <IconWrapper {...props}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></IconWrapper>,
            Lightbulb: (props) => <IconWrapper {...props}><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2.4 1.5-3.8 0-3.3-2.7-6-6-6S6 4.7 6 8c0 1.4.5 2.8 1.5 3.8.8.8 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></IconWrapper>,
            TrendingUp: (props) => <IconWrapper {...props}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></IconWrapper>,
            Clock: (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconWrapper>,
            Code: (props) => <IconWrapper {...props}><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></IconWrapper>,
            FlaskConical: (props) => <IconWrapper {...props}><path d="M10 2v7.527a2 2 0 0 1-.211.896L4.72 20.55a1 1 0 0 0 .9 1.45h12.76a1 1 0 0 0 .9-1.45l-5.069-10.127A2 2 0 0 1 14 9.527V2"/><path d="M8.5 2h7"/><path d="M7 16h10"/></IconWrapper>,
            Scale: (props) => <IconWrapper {...props}><path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="M7 21h10"/><path d="M12 3v18"/><path d="M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2"/></IconWrapper>,
            XCircle: (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></IconWrapper>,
            FileText: (props) => <IconWrapper {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></IconWrapper>,
            GitBranch: (props) => <IconWrapper {...props}><line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/></IconWrapper>,
            Search: (props) => <IconWrapper {...props}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></IconWrapper>,
        };

        // --- 3D Components ---

        const ParticleSphere = () => {
            const canvasRef = useRef(null);
            
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let width = canvas.width = canvas.offsetWidth;
                let height = canvas.height = canvas.offsetHeight;
                
                let particles = [];
                const particleCount = 80;
                const connectionDistance = 100;
                let mouse = { x: 0, y: 0 };
                
                class Particle {
                    constructor() {
                        this.x = (Math.random() - 0.5) * width;
                        this.y = (Math.random() - 0.5) * height;
                        this.z = (Math.random() - 0.5) * width;
                        this.vx = (Math.random() - 0.5) * 0.5;
                        this.vy = (Math.random() - 0.5) * 0.5;
                        this.vz = (Math.random() - 0.5) * 0.5;
                        this.size = Math.random() * 2 + 1;
                    }

                    update(rotX, rotY) {
                        const cosX = Math.cos(rotX);
                        const sinX = Math.sin(rotX);
                        const cosY = Math.cos(rotY);
                        const sinY = Math.sin(rotY);

                        let x1 = this.x * cosY - this.z * sinY;
                        let z1 = this.z * cosY + this.x * sinY;
                        let y1 = this.y * cosX - z1 * sinX;
                        let z2 = z1 * cosX + this.y * sinX;

                        this.x = x1;
                        this.y = y1;
                        this.z = z2;
                        this.x += this.vx;
                        this.y += this.vy;
                        this.z += this.vz;

                        const limit = width / 2;
                        if (Math.abs(this.x) > limit) this.vx *= -1;
                        if (Math.abs(this.y) > limit) this.vy *= -1;
                        if (Math.abs(this.z) > limit) this.vz *= -1;
                    }

                    draw(ctx, width, height) {
                        const fov = 300;
                        const scale = fov / (fov + this.z);
                        const x2d = this.x * scale + width / 2;
                        const y2d = this.y * scale + height / 2;
                        
                        if (scale > 0) {
                            ctx.globalAlpha = Math.min(1, (scale - 0.2) * 1);
                            ctx.fillStyle = '#818cf8';
                            ctx.beginPath();
                            ctx.arc(x2d, y2d, this.size * scale, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return { x: x2d, y: y2d, scale };
                    }
                }

                for (let i = 0; i < particleCount; i++) particles.push(new Particle());

                const handleMouseMove = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = (e.clientX - rect.left - width / 2) * 0.0001;
                    mouse.y = (e.clientY - rect.top - height / 2) * 0.0001;
                };

                const animate = () => {
                    ctx.clearRect(0, 0, width, height);
                    const rotY = 0.002 + mouse.x * 5;
                    const rotX = 0.002 + mouse.y * 5;

                    const projectedPoints = particles.map(p => {
                        p.update(rotX, rotY);
                        return p.draw(ctx, width, height);
                    });

                    ctx.strokeStyle = '#c7d2fe';
                    ctx.lineWidth = 0.5;
                    for (let i = 0; i < particles.length; i++) {
                        for (let j = i + 1; j < particles.length; j++) {
                            const p1 = projectedPoints[i];
                            const p2 = projectedPoints[j];
                            if (!p1 || !p2) continue;
                            const dx = p1.x - p2.x;
                            const dy = p1.y - p2.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < connectionDistance * p1.scale) {
                                ctx.globalAlpha = (1 - dist / (connectionDistance * p1.scale)) * 0.3;
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        }
                    }
                    requestAnimationFrame(animate);
                };

                animate();
                window.addEventListener('mousemove', handleMouseMove);
                
                const handleResize = () => {
                    width = canvas.width = canvas.offsetWidth;
                    height = canvas.height = canvas.offsetHeight;
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('resize', handleResize);
                };
            }, []);

            return <canvas ref={canvasRef} className="absolute inset-0 w-full h-full pointer-events-none z-0" />;
        };

        const TiltCard = ({ children, className = "", rotateScale = 1 }) => {
            const x = useMotionValue(0);
            const y = useMotionValue(0);
            const mouseX = useSpring(x, { stiffness: 500, damping: 100 });
            const mouseY = useSpring(y, { stiffness: 500, damping: 100 });
            const rotateX = useTransform(mouseY, [-0.5, 0.5], [`${8 * rotateScale}deg`, `${-8 * rotateScale}deg`]);
            const rotateY = useTransform(mouseX, [-0.5, 0.5], [`${-8 * rotateScale}deg`, `${8 * rotateScale}deg`]);

            const handleMouseMove = (e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                x.set((e.clientX - rect.left - rect.width / 2) / rect.width);
                y.set((e.clientY - rect.top - rect.height / 2) / rect.height);
            };

            return (
                <motion.div
                    style={{ rotateX, rotateY, transformStyle: "preserve-3d" }}
                    onMouseMove={handleMouseMove}
                    onMouseLeave={() => { x.set(0); y.set(0); }}
                    className={`relative transition-all duration-200 ease-out ${className}`}
                >
                    {children}
                </motion.div>
            );
        };

        const Section = ({ title, icon: Icon, children, className = "" }) => (
            <motion.div 
                initial={{ opacity: 0, y: 20 }}
                whileInView={{ opacity: 1, y: 0 }}
                viewport={{ once: true }}
                className={`bg-white rounded-2xl shadow-sm border border-gray-100 p-8 mb-8 ${className}`}
            >
                <div className="flex items-center gap-3 mb-6 border-b border-gray-100 pb-4">
                    <div className="p-2.5 bg-gradient-to-br from-blue-50 to-indigo-100 rounded-xl text-blue-600">
                        <Icon size={24} />
                    </div>
                    <h2 className="text-2xl font-bold text-gray-800">{title}</h2>
                </div>
                <div>{children}</div>
            </motion.div>
        );

        const FeatureCard = ({ title, desc, icon: Icon, color }) => {
            const style = {
                purple: "bg-purple-50 text-purple-900 border-purple-200 from-purple-50 to-white",
                green: "bg-emerald-50 text-emerald-900 border-emerald-200 from-emerald-50 to-white",
                blue: "bg-blue-50 text-blue-900 border-blue-200 from-blue-50 to-white",
            }[color];
            
            return (
                <TiltCard className="h-full">
                    <div className={`h-full p-6 rounded-xl border bg-gradient-to-br ${style} shadow-sm hover:shadow-md transition-shadow flex flex-col`}>
                        <div style={{ transform: "translateZ(20px)" }} className="mb-3">
                            <Icon size={32} className="opacity-80" />
                        </div>
                        <h4 style={{ transform: "translateZ(15px)" }} className="font-bold text-lg mb-2">{title}</h4>
                        <p style={{ transform: "translateZ(10px)" }} className="text-sm opacity-80 leading-relaxed flex-grow">{desc}</p>
                    </div>
                </TiltCard>
            );
        };

        const Architecture3D = () => {
            const [activeStep, setActiveStep] = useState(1);
            
            const steps = [
                { id: 1, title: "Shared Encoder", short: "Input Processing", color: "from-blue-100 to-blue-200", border: "border-blue-300", content: "扩散模型和 AR 模型共享同一个 Transformer Encoder。它将 Prompt 编码为基础特征，确保两者在相同的语义空间下工作。" },
                { id: 2, title: "Diffusion (Think)", short: "Latent Planning", color: "from-purple-100 to-purple-200", border: "border-purple-300", content: "核心创新点。它不是生成离散的 Token，而是在连续的潜在空间 (Hidden States) 中进行去噪。它可以一次性并行生成未来 K 个步骤的'思维向量' (Latent Thoughts)，规划全局逻辑。" },
                { id: 3, title: "AR Decoder (Talk)", short: "Token Generation", color: "from-emerald-100 to-emerald-200", border: "border-emerald-300", content: "标准的自回归解码器。它接收 Diffusion 生成的思维向量作为条件 (Condition)，逐个生成最终的 Token。如果 AR 发现思维向量不合理，它有能力进行修正。" },
                { id: 4, title: "Objective", short: "Joint Training", color: "from-orange-100 to-orange-200", border: "border-orange-300", content: "联合训练目标：L = L_AR + λ * L_Diff。最大化证据下界 (ELBO)。Diffusion 负责逼近真实的后验分布，AR 负责似然最大化。" }
            ];

            return (
                <div className="space-y-6">
                    <div className="flex flex-col md:flex-row items-stretch justify-center gap-4 py-4">
                        {steps.map((step, index) => (
                            <React.Fragment key={step.id}>
                                <div className="flex-1 min-w-[140px]" onClick={() => setActiveStep(step.id)}>
                                    <TiltCard className="h-full cursor-pointer" rotateScale={1.5}>
                                        <div className={`h-full flex flex-col items-center justify-center p-4 rounded-xl border-b-4 shadow-md transition-all bg-gradient-to-b ${step.color} ${step.border} ${activeStep === step.id ? 'ring-4 ring-offset-2 ring-indigo-300 scale-105' : 'hover:scale-105'}`}>
                                            <span className="text-xs font-bold uppercase tracking-wider opacity-70 mb-1" style={{ transform: "translateZ(10px)" }}>Step {step.id}</span>
                                            <h4 className="font-bold text-center text-gray-800" style={{ transform: "translateZ(20px)" }}>{step.title}</h4>
                                            <p className="text-xs text-center text-gray-600 mt-1" style={{ transform: "translateZ(15px)" }}>{step.short}</p>
                                        </div>
                                    </TiltCard>
                                </div>
                                {index < steps.length - 1 && (
                                    <div className="flex items-center justify-center text-gray-300">
                                        <Icons.ArrowRight size={24} className="hidden md:block" />
                                        <Icons.ArrowRight size={24} className="md:hidden rotate-90" />
                                    </div>
                                )}
                            </React.Fragment>
                        ))}
                    </div>

                    <AnimatePresence mode='wait'>
                        <motion.div
                            key={activeStep}
                            initial={{ opacity: 0, y: 20 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -20 }}
                            transition={{ duration: 0.3 }}
                            className="bg-gray-900 text-white p-6 rounded-2xl border border-gray-700 shadow-xl"
                        >
                            <div className="flex items-center gap-3 mb-3">
                                <div className={`p-2 rounded-lg bg-gradient-to-br ${steps[activeStep-1].color} text-gray-900`}>
                                    {activeStep === 1 && <Icons.FileText size={20}/>}
                                    {activeStep === 2 && <Icons.Brain size={20}/>}
                                    {activeStep === 3 && <Icons.Cpu size={20}/>}
                                    {activeStep === 4 && <Icons.Scale size={20}/>}
                                </div>
                                <h3 className="text-xl font-bold">{steps[activeStep-1].title}</h3>
                            </div>
                            <p className="text-gray-300 leading-relaxed text-lg">{steps[activeStep-1].content}</p>
                            
                            <div className="mt-4 p-3 bg-black/30 rounded-lg font-mono text-xs md:text-sm text-green-400 border border-white/10 overflow-x-auto">
                                {activeStep === 1 && "h_enc = Encoder(prompt)"}
                                {activeStep === 2 && "h_diff = Denoise(Gaussian_Noise, condition=h_enc)  // Parallel Generation"}
                                {activeStep === 3 && "p(x_t | x_<t) = AR(x_<t, condition=h_diff)       // Sequential/Speculative"}
                                {activeStep === 4 && "Loss = -log p_AR(x) + λ * || h_diff - h_true ||^2  // Joint Optimization"}
                            </div>
                        </motion.div>
                    </AnimatePresence>
                </div>
            );
        };

        const SSDAnimation = () => {
            const [step, setStep] = useState(0);
            const totalSteps = 4;
            
            useEffect(() => {
                const timer = setInterval(() => {
                    setStep((prev) => (prev + 1) % totalSteps);
                }, 2500);
                return () => clearInterval(timer);
            }, []);

            const tokens = ["The", "quick", "brown", "fox", "jumps", "over"];

            return (
                <TiltCard className="h-full">
                    <div className="bg-gradient-to-br from-gray-900 to-gray-800 rounded-2xl p-6 border border-gray-700 h-full flex flex-col relative overflow-hidden">
                        <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'radial-gradient(#818cf8 1px, transparent 1px)', backgroundSize: '20px 20px'}}></div>
                        
                        <div className="relative z-10">
                            <h3 className="text-lg font-bold text-white mb-2 flex items-center gap-2" style={{ transform: "translateZ(20px)" }}>
                                <Icons.Zap className="text-yellow-400" size={20}/> SSD 动态演示
                            </h3>
                            <p className="text-xs text-gray-400 mb-6">自投机采样：Diffusion (Drafter) 并行预测，AR (Verifier) 并行验证。</p>

                            <div className="space-y-6 px-2">
                                <div className={`transition-opacity duration-500 ${step % 2 === 0 ? 'opacity-100' : 'opacity-50'}`}>
                                    <div className="flex items-center gap-3 mb-2">
                                        <span className="bg-purple-600/20 text-purple-300 text-xs px-2 py-0.5 rounded border border-purple-500/30">THINK (Diffusion)</span>
                                        <span className="text-xs text-gray-500">并行生成潜在状态...</span>
                                    </div>
                                    <div className="h-8 bg-gray-800/50 rounded-lg flex items-center px-3 gap-2 border border-gray-700">
                                        {step >= 2 && [1,2,3].map(i => <div key={`old-l-${i}`} className="w-2 h-2 rounded-full bg-purple-500/30"></div>)}
                                        {step % 2 === 0 && (
                                            <div className="flex gap-2">
                                                {[1, 2, 3].map((i) => (
                                                    <motion.div 
                                                        key={`latent-${step}-${i}`}
                                                        initial={{ scale: 0, opacity: 0 }}
                                                        animate={{ scale: 1, opacity: 1 }}
                                                        transition={{ delay: i * 0.1 }}
                                                        className="w-2 h-2 rounded-full bg-purple-400 shadow-[0_0_10px_#a855f7]"
                                                    />
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                </div>

                                <div className={`transition-opacity duration-500 ${step % 2 !== 0 ? 'opacity-100' : 'opacity-50'}`}>
                                    <div className="flex items-center gap-3 mb-2">
                                        <span className="bg-emerald-600/20 text-emerald-300 text-xs px-2 py-0.5 rounded border border-emerald-500/30">TALK (AR)</span>
                                        <span className="text-xs text-gray-500">并行验证并生成...</span>
                                    </div>
                                    <div className="min-h-10 flex flex-wrap gap-2">
                                        {step >= 2 && tokens.slice(0, 3).map((t, i) => (
                                            <span key={`done-${i}`} className="text-gray-400 text-sm bg-gray-800 px-2 py-1 rounded border border-gray-700">{t}</span>
                                        ))}
                                        {step % 2 !== 0 && (
                                            <>
                                                {(step === 1 ? tokens.slice(0, 3) : tokens.slice(3, 6)).map((t, i) => (
                                                    <motion.span
                                                        key={`token-${step}-${i}`}
                                                        initial={{ y: 10, opacity: 0 }}
                                                        animate={{ y: 0, opacity: 1 }}
                                                        transition={{ delay: i * 0.15 }}
                                                        className="text-emerald-300 text-sm bg-emerald-900/30 px-2 py-1 rounded border border-emerald-500/50 font-bold"
                                                    >
                                                        {t}
                                                    </motion.span>
                                                ))}
                                            </>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </TiltCard>
            );
        };

        // --- Main App ---

        const App = () => {
            const [activeTab, setActiveTab] = useState('overview');
            const [quizAnswers, setQuizAnswers] = useState({});
            const [showQuizResults, setShowQuizResults] = useState({});

            const handleQuizSelect = (qId, optionId) => setQuizAnswers(prev => ({ ...prev, [qId]: optionId }));
            const checkAnswer = (qId) => setShowQuizResults(prev => ({ ...prev, [qId]: true }));

            const quizData = [
                { id: 1, question: "TiDAR 的扩散模型部分生成的是什么？", options: [{id:'a',text:"最终的离散 Token"},{id:'b',text:"连续的潜在思维向量 (Latent Thoughts)"},{id:'c',text:"Prompt 的压缩编码"},{id:'d',text:"AR 模型的权重参数"}], correct: 'b' },
                { id: 2, question: "在自投机采样 (SSD) 中，Diffusion 模型扮演什么角色？", options: [{id:'a',text:"Verifier (验证者)"},{id:'b',text:"Drafter (草稿生成者)"},{id:'c',text:"Tokenizer (分词器)"},{id:'d',text:"Loss Calculator (损失计算器)"}], correct: 'b' },
                { id: 3, question: "TiDAR 的联合训练目标函数由哪两部分组成？", options: [{id:'a',text:"GAN 判别器损失 + 生成器损失"},{id:'b',text:"AR 似然损失 + Diffusion 去噪损失"},{id:'c',text:"强化学习奖励 + 策略梯度"},{id:'d',text:"Transformer 交叉熵 + BERT 掩码损失"}], correct: 'b' },
                { id: 4, question: "TiDAR 在 GSM8K 和 MATH 等推理任务上表现优异的主要原因是什么？", options: [{id:'a',text:"因为使用了更多的数据集进行微调"},{id:'b',text:"因为扩散模型提供了全局规划 (Global Planning) 能力"},{id:'c',text:"因为完全摒弃了 AR 结构"},{id:'d',text:"因为模型参数量比基线模型大得多"}], correct: 'b' },
                { id: 5, question: "相比于其他的 Diff-AR 混合模型，TiDAR 的主要区别在于？", options: [{id:'a',text:"TiDAR 的扩散部分是在连续潜在空间 (Latent Space) 工作"},{id:'b',text:"TiDAR 的 AR 部分不生成任何文本"},{id:'c',text:"TiDAR 只用于图像生成"},{id:'d',text:"TiDAR 不需要训练"}], correct: 'a' },
                { id: 6, question: "TiDAR 目前的一个主要局限性是什么？", options: [{id:'a',text:"生成的文本质量极差"},{id:'b',text:"无法进行指令遵循"},{id:'c',text:"训练开销较大，因为需要同时训练两个解码器"},{id:'d',text:"推理速度比纯 AR 慢很多"}], correct: 'c' }
            ];

            const navItems = [
                { id: 'overview', label: '概览', icon: Icons.BookOpen },
                { id: 'method', label: '方法', icon: Icons.Layers },
                { id: 'experiments', label: '实验', icon: Icons.FlaskConical },
                { id: 'analysis', label: '分析', icon: Icons.Search },
                { id: 'quiz', label: '测验', icon: Icons.CheckCircle },
            ];

            const renderContent = () => {
                switch(activeTab) {
                    case 'overview':
                        return (
                            <div className="space-y-8">
                                <div className="relative bg-gray-900 rounded-3xl overflow-hidden min-h-[360px] flex items-center shadow-2xl">
                                    <ParticleSphere />
                                    <div className="absolute inset-0 bg-gradient-to-r from-gray-900 via-gray-900/85 to-transparent z-10 pointer-events-none"></div>
                                    <motion.div initial={{ opacity: 0, x: -30 }} animate={{ opacity: 1, x: 0 }} className="relative z-20 p-10 max-w-2xl">
                                        <div className="inline-block px-3 py-1 mb-4 rounded-full bg-indigo-500/20 border border-indigo-400/30 text-indigo-300 text-xs font-bold tracking-wider uppercase">2025 SOTA Paper</div>
                                        <h1 className="text-4xl md:text-6xl font-extrabold mb-6 text-white leading-tight">TiDAR</h1>
                                        <p className="text-xl text-gray-300 mb-8 font-light"><span className="font-bold text-purple-400">Think in Diffusion</span> (全局规划)<br/><span className="font-bold text-emerald-400">Talk in Autoregression</span> (精准表达)</p>
                                        <button onClick={() => setActiveTab('method')} className="bg-white text-gray-900 px-6 py-3 rounded-lg font-bold hover:bg-gray-100 transition-colors flex items-center gap-2 shadow-lg">深入技术细节 <Icons.ArrowRight size={18} /></button>
                                    </motion.div>
                                </div>
                                <div className="grid md:grid-cols-2 gap-6">
                                    <Section title="研究背景：AR 的局限" icon={Icons.HelpCircle}>
                                        <ul className="space-y-4 text-gray-600">
                                            <li className="bg-red-50 p-3 rounded-lg border border-red-100"><span className="font-bold text-red-700 block mb-1">Myopic (短视)</span>传统的自回归 (AR) 模型在生成每个词时，只基于已生成的词，缺乏对整句或整段话的“上帝视角”规划。</li>
                                            <li className="bg-orange-50 p-3 rounded-lg border border-orange-100"><span className="font-bold text-orange-700 block mb-1">Serial (串行低效)</span>逐个 Token 生成的方式无法充分利用 GPU 并行算力，导致长文本生成延迟高。</li>
                                        </ul>
                                    </Section>
                                    <Section title="TiDAR 的核心洞察" icon={Icons.Lightbulb}>
                                        <p className="text-gray-600 mb-4">人类的表达通常是<b>先有腹稿 (Think)，再组织语言 (Talk)</b>。TiDAR 将这一过程建模为：</p>
                                        <div className="space-y-3">
                                            <div className="flex items-center gap-3 p-3 bg-purple-50 rounded-lg border border-purple-100"><Icons.Brain className="text-purple-600" size={24}/><div className="text-sm text-gray-700"><b>Diffusion (Think):</b> 在连续潜在空间中，并行规划全局的“思维骨架”。</div></div>
                                            <div className="flex items-center gap-3 p-3 bg-emerald-50 rounded-lg border border-emerald-100"><Icons.Cpu className="text-emerald-600" size={24}/><div className="text-sm text-gray-700"><b>Autoregression (Talk):</b> 根据骨架，利用 AR 的语言能力填充具体 Token。</div></div>
                                        </div>
                                    </Section>
                                </div>
                            </div>
                        );
                    case 'method':
                        return (
                            <div className="space-y-8">
                                <Section title="TiDAR 架构详解" icon={Icons.Layers}>
                                    <p className="text-gray-600 mb-6">TiDAR 采用双解码器架构。点击下方流程卡片，查看各个组件的详细技术实现。</p>
                                    <Architecture3D />
                                </Section>
                                <div className="grid lg:grid-cols-2 gap-8">
                                    <Section title="自投机采样 (SSD)" icon={Icons.Zap}>
                                        <p className="text-gray-600 mb-4 text-sm">这是 TiDAR 的核心推理算法。利用 Diffusion 的并行能力作为 Draft Model，实现<b>无损加速</b>。</p>
                                        <SSDAnimation />
                                    </Section>
                                    <Section title="训练策略" icon={Icons.GitBranch}>
                                        <div className="space-y-4 h-full">
                                            <TiltCard className="h-full">
                                                <div className="p-5 bg-gray-50 rounded-xl border border-gray-200 h-full flex flex-col justify-center">
                                                    <h4 className="font-bold text-gray-800 mb-2 flex items-center gap-2" style={{ transform: "translateZ(10px)" }}><Icons.Scale size={18} className="text-indigo-500"/> 联合损失函数</h4>
                                                    <p className="text-sm text-gray-600 font-mono bg-white p-2 rounded border border-gray-100 mb-2 shadow-inner" style={{ transform: "translateZ(15px)" }}>L = L_AR + λ * L_Diff</p>
                                                    <p className="text-xs text-gray-500 leading-relaxed" style={{ transform: "translateZ(5px)" }}>在训练时，同时优化 AR 的下一个词预测准确率和 Diffusion 的去噪能力。这种联合训练确保了“思维向量”既能被 Diffusion 生成，又能被 AR 理解。</p>
                                                </div>
                                            </TiltCard>
                                        </div>
                                    </Section>
                                </div>
                            </div>
                        );
                    case 'experiments':
                        return (
                            <div className="space-y-8">
                                <Section title="主要实验结果" icon={Icons.BarChart3}>
                                    <p className="text-gray-600 mb-8">TiDAR 在生成任务、似然评估任务和复杂的推理任务上都进行了广泛的基准测试。</p>
                                    <div className="mb-8">
                                        <h3 className="font-bold text-xl text-gray-800 mb-4 flex items-center gap-2"><Icons.FlaskConical className="text-purple-500"/> 1. 推理任务 (Reasoning)</h3>
                                        <div className="grid grid-cols-2 gap-4 h-64">
                                            <TiltCard className="bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col h-full">
                                                <h4 className="text-center font-bold text-gray-600 mb-4">GSM8K Accuracy</h4>
                                                <div className="flex items-end justify-center gap-4 flex-grow px-2">
                                                    {[{ name: 'Llama-2', val: 55.4, h: '55%' }, { name: 'TiDAR', val: 63.2, h: '63%', active: true }].map((d, i) => (
                                                        <div key={i} className="flex flex-col items-center w-1/2 h-full justify-end">
                                                            <span className={`font-bold mb-1 ${d.active ? 'text-indigo-600' : 'text-gray-400'}`}>{d.val}%</span>
                                                            <motion.div initial={{height:0}} whileInView={{height: d.h}} className={`w-full rounded-t-lg ${d.active ? 'bg-indigo-600' : 'bg-gray-300'}`}></motion.div>
                                                            <span className="text-xs mt-2 font-bold text-gray-500">{d.name}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            </TiltCard>
                                            <TiltCard className="bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col h-full">
                                                <h4 className="text-center font-bold text-gray-600 mb-4">MATH Accuracy</h4>
                                                <div className="flex items-end justify-center gap-4 flex-grow px-2">
                                                    {[{ name: 'Llama-2', val: 12.5, h: '25%' }, { name: 'TiDAR', val: 18.8, h: '38%', active: true }].map((d, i) => (
                                                        <div key={i} className="flex flex-col items-center w-1/2 h-full justify-end">
                                                            <span className={`font-bold mb-1 ${d.active ? 'text-emerald-600' : 'text-gray-400'}`}>{d.val}%</span>
                                                            <motion.div initial={{height:0}} whileInView={{height: d.h}} className={`w-full rounded-t-lg ${d.active ? 'bg-emerald-600' : 'bg-gray-300'}`}></motion.div>
                                                            <span className="text-xs mt-2 font-bold text-gray-500">{d.name}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            </TiltCard>
                                        </div>
                                    </div>
                                    <div className="grid md:grid-cols-2 gap-8">
                                        <div>
                                            <h3 className="font-bold text-xl text-gray-800 mb-4 flex items-center gap-2"><Icons.TrendingUp className="text-blue-500"/> 2. 速度基准 (Speedup)</h3>
                                            <div className="bg-gray-50 p-4 rounded-xl border border-gray-200">
                                                <div className="space-y-4">
                                                    {[{ name: 'Diffusion Only', speed: '1.0x (Baseline)', w: '30%' }, { name: 'Standard AR', speed: '1.51x', w: '45%' }, { name: 'TiDAR (SSD)', speed: '2.84x', w: '85%', active: true }].map((item, i) => (
                                                        <div key={i}>
                                                            <div className="flex justify-between text-sm mb-1"><span>{item.name}</span><span className="font-bold">{item.speed}</span></div>
                                                            <div className="h-2 bg-gray-200 rounded-full overflow-hidden"><motion.div initial={{width: 0}} whileInView={{width: item.w}} className={`h-full ${item.active ? 'bg-blue-600' : 'bg-gray-400'}`}/></div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                        <div>
                                            <h3 className="font-bold text-xl text-gray-800 mb-4 flex items-center gap-2"><Icons.FileText className="text-orange-500"/> 3. 生成质量 (MT-Bench)</h3>
                                            <div className="bg-gray-50 p-6 rounded-xl border border-gray-200 h-40 flex items-center justify-center text-center">
                                                <div>
                                                    <p className="text-gray-600 text-sm mb-2">在指令遵循 (Instruction Following) 任务中</p>
                                                    <div className="text-3xl font-extrabold text-gray-800">TiDAR <span className="text-green-600">≈</span> GPT-3.5</div>
                                                    <p className="text-xs text-gray-500 mt-2">在保持生成质量的同时，显著提升了逻辑一致性。</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </Section>
                            </div>
                        );
                    case 'analysis':
                        return (
                            <div className="space-y-8">
                                <Section title="深入分析 (Ablation Studies)" icon={Icons.Search}>
                                    <p className="text-gray-600 mb-6">为了验证 TiDAR 各个组件的有效性，论文进行了详细的消融实验。</p>
                                    <div className="grid md:grid-cols-3 gap-4">
                                        <FeatureCard icon={Icons.Brain} title="Only Think?" desc="如果只使用 Diffusion 生成连续向量并解码？结果：生成的文本语法错误较多，缺乏 AR 的局部平滑性。" color="purple"/>
                                        <FeatureCard icon={Icons.Cpu} title="Only Talk?" desc="如果只用 AR（即 Base 模型）？结果：在长逻辑链任务中容易出错，缺乏全局规划。" color="green"/>
                                        <FeatureCard icon={Icons.Layers} title="Think + Talk" desc="TiDAR 的完整模式。结合了 Diffusion 的规划能力和 AR 的语法能力，效果最佳。" color="blue"/>
                                    </div>
                                </Section>
                                <Section title="局限性与未来方向" icon={Icons.XCircle}>
                                    <ul className="space-y-3 text-gray-700 text-sm">
                                        <li className="flex gap-3"><div className="mt-1 w-2 h-2 rounded-full bg-red-500 shrink-0"></div><p><b>计算开销：</b> 虽然推理速度快，但训练时需要同时训练两个解码器，资源消耗较大。</p></li>
                                        <li className="flex gap-3"><div className="mt-1 w-2 h-2 rounded-full bg-red-500 shrink-0"></div><p><b>Latent 对齐：</b> 确保 Diffusion 生成的潜在状态能完美被 AR 解码器理解仍然是一个优化难点。</p></li>
                                        <li className="flex gap-3"><div className="mt-1 w-2 h-2 rounded-full bg-blue-500 shrink-0"></div><p><b>未来方向：</b> 探索在更大规模模型（如 70B+）上的扩展性，以及在多模态任务中的应用。</p></li>
                                    </ul>
                                </Section>
                            </div>
                        );
                    case 'quiz':
                        return (
                            <div className="max-w-3xl mx-auto">
                                <div className="bg-white rounded-2xl shadow-sm border border-gray-100 p-10">
                                    <div className="text-center mb-10">
                                        <h2 className="text-3xl font-bold text-gray-800 mb-2">TiDAR 专家测验</h2>
                                        <p className="text-gray-500">检验你对论文技术细节的掌握</p>
                                    </div>
                                    <div className="space-y-6">
                                        {quizData.map((q, index) => (
                                            <div key={q.id} className="border-b border-gray-100 pb-6 last:border-0">
                                                <h3 className="font-bold text-lg mb-4 text-gray-800">{index + 1}. {q.question}</h3>
                                                <div className="space-y-2">
                                                    {q.options.map((opt) => (
                                                        <div 
                                                            key={opt.id} 
                                                            onClick={() => !showQuizResults[q.id] && handleQuizSelect(q.id, opt.id)}
                                                            className={`p-3 rounded-lg border cursor-pointer transition-all flex justify-between items-center ${showQuizResults[q.id] ? opt.id === q.correct ? 'bg-green-100 border-green-500 text-green-800' : quizAnswers[q.id] === opt.id ? 'bg-red-100 border-red-500 text-red-800' : 'opacity-50' : quizAnswers[q.id] === opt.id ? 'bg-indigo-50 border-indigo-500 text-indigo-800' : 'hover:bg-gray-50'}`}
                                                        >
                                                            <span>{opt.text}</span>
                                                            {showQuizResults[q.id] && opt.id === q.correct && <Icons.CheckCircle size={18}/>}
                                                        </div>
                                                    ))}
                                                </div>
                                                {!showQuizResults[q.id] && quizAnswers[q.id] && (<div className="mt-3 text-right"><button onClick={() => checkAnswer(q.id)} className="text-sm font-bold text-indigo-600 hover:underline">提交答案</button></div>)}
                                                {showQuizResults[q.id] && (<div className="mt-2 text-sm text-gray-500">{quizAnswers[q.id] === q.correct ? "正确！" : `错误。正确答案是：${q.options.find(o=>o.id===q.correct).text}`}</div>)}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        );
                    default: return null;
                }
            };

            return (
                <div className="min-h-screen bg-gray-50 font-sans text-gray-900">
                    <nav className="bg-white/80 backdrop-blur-md border-b border-gray-200 sticky top-0 z-50">
                        <div className="max-w-6xl mx-auto px-4">
                            <div className="flex justify-between h-16 items-center">
                                <div className="flex items-center gap-2 font-bold text-xl cursor-pointer" onClick={() => setActiveTab('overview')}>
                                    <div className="bg-indigo-600 p-1.5 rounded text-white"><Icons.Brain size={20} /></div>
                                    <span>TiDAR <span className="text-gray-400 text-sm font-normal">V3 Plus</span></span>
                                </div>
                                <div className="hidden md:flex gap-1">
                                    {navItems.map((item) => (
                                        <button key={item.id} onClick={() => setActiveTab(item.id)} className={`px-4 py-2 rounded-lg text-sm font-medium transition-all flex items-center gap-2 ${activeTab === item.id ? 'bg-indigo-50 text-indigo-700' : 'text-gray-600 hover:bg-gray-100'}`}><item.icon size={16} />{item.label}</button>
                                    ))}
                                </div>
                            </div>
                        </div>
                        <div className="md:hidden overflow-x-auto flex border-t border-gray-100 bg-white no-scrollbar">
                            {navItems.map((item) => (<button key={item.id} onClick={() => setActiveTab(item.id)} className={`flex-shrink-0 px-5 py-3 text-xs font-bold border-b-2 transition-colors ${activeTab === item.id ? 'border-indigo-600 text-indigo-600' : 'border-transparent text-gray-500'}`}>{item.label}</button>))}
                        </div>
                    </nav>
                    <main className="max-w-6xl mx-auto px-4 py-8 md:py-12">
                        <AnimatePresence mode='wait'>
                            <motion.div key={activeTab} initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} transition={{ duration: 0.2 }}>
                                {renderContent()}
                            </motion.div>
                        </AnimatePresence>
                    </main>
                    <footer className="bg-white border-t border-gray-200 py-8 mt-12 text-center text-gray-500 text-sm"><p>基于论文: TiDAR: Think in Diffusion, Talk in Autoregression (2025)</p></footer>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>